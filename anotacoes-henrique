@ResponseBody <- @RestController
- o retorno dos métodos dentro da classe serão apenas Strings
- imbutido na classe annotation @RestController


Jackson 
- serializador oficial do Spring
- criar os atributos JSON utilizando os GETTERS/SETTERS (error: 500 caso não tenha os get/set)


@Component
- transformar a classe em Bean (classe escaneável) para que o Spring possa trabalhar com ela
- @Controller e @Service são (quase) a mesma coisa

@RequiredArgsConstructor
- criar um Construtor da classe com somente métodos "final"

@Configuration
- transformar a classe em um Bean
- Marca a classe como uma fonte de definições de bean para o contexto do aplicativo
- vai colocar a classe de configuração no meio do "Filter Chain" (corrente de filtros)

@EnableAutoConfiguration
- configuração de propriedades, classes a serem executadas, etc.
- Diz ao Spring Boot para começar a adicionar beans com base nas configurações do classpath, outros beans e várias configurações de propriedade...
- ...Por exemplo, se spring-webmvcestiver no caminho de classe, essa anotação sinaliza o aplicativo como um aplicativo da web
- ... e ativa os principais comportamentos, como configurar um DispatcherServlet.

@ComponentScan
- varrer os pacotes, com as classes, no pacote principal onde essa anotação estiver 
- Diz ao Spring para procurar outros componentes, configurações e serviços no com/examplepacote, permitindo que ele encontre os controladores.

Básico do Spring para se inicializar uma aplicação, escanear toda a config e os componentes
- @EnableAutoConfiguration
- @ComponentScan		
- @Configuration

@SpringBootApplication
- é uma anotação de conveniência que adiciona todos os seguintes: @Configuration / @EnableAutoConfiguration / @ComponentScan 

// --- 05 --- //

Ao inserir a dependência Spring Boot Devtools
- Spring habilitará o Hot Swap, e entre outras coisas

Hot Swap 
- fazer somente o Build de pequenas mudanças feitas no código e não precisar reiniciar a aplicação inteira
- melhor performance, menos tempo, para rodar a aplicação

// --- 07 --- //

@Data 
- gerar getters/setters, hashCode e equals, toString, ...

@AllArgsConstructor
- gerar construtor com todos os atributos







Pacotes / Classes e suas responsabilidades
- Controllers: onde são os endpoints
- Service: lógica regra de negócios
- Repositories: a conexão diretamente com o banco de dados (Query's ficarão aqui)
- Entities: o que se tem no banco de dados








// --- 08 --- // - GET

ResponseEntity<>
- retornar informações extras de uma requisição HTTP. Ex: o status da requisição
- quando a resposta da requisição retornar direitinho, sem nenhum erro, não terá nenhuma alteração no resultado

.orElseThrow()		[ 5:35 ]
- na stream, retornar algo caso não encontre o objeto pedido
- por convenção as pessoas lançam o "Error 404", mas ele não apresenta tantas informções, então fazer um padrão mais explicativo
- no código utilizar um padrão, ou seja, usou no endpoint o - HttpStatus.BAD_REQUEST - então usar em outros endpoints também

properties.application -> propoerties.yml		[ 8:12 ]
- esconder o Stack Trace na requisição GET do erro do método finById() caso não seja encontrado um animal com aquele id

// --- 09 --- // - POST

O padrão de retorno de dados é o que define (Ex: o .orElseThrow acima)

Nesse caso irá se retornar um objeto inteiro

Há muitos lugares onde quando se faz a requisição POST, pode se receber no retorno:
- ou apenas um ID e um protocolo 201 (CREATED)
- ou só o protocolo 201 sem nenhum outro tipo de retorno
- ou o objeto inteiro


O método save() precisa de um "body" = ou seja, esse requisição precisa receber um objeto e ser mapeada para salva-la
- nesse caso usar o Jackson para fazer o mapeamento

Jackson funciona assim: 
- se ele encontrar o JSON com os atributos da requisição exatamente iguais aos atributos da classe ele fará o mapeamento
- caso o atributo não esteja como o mesmo nome ele será ignorado, não será mapeado (utilizar o @JsonProperty)

@JsonProperty
- fará com o que o atributo JSON seja mapeado mesmo sendo diferente do atributo classe 
- Ex:	
		@JsonProperty("name") // como será na requisição e ser mapeado para esse atributo da classe
		private nameCharacter; 
		
@ResponseStatus("HttpStatus.CREATED")
- retornar o protocolo 201 (CREATED)

// --- 10 --- // - DELETE

Padrão em retornar o BAD_REQUEST permanece
- animais.remove(findById(id)); // findById() que irá retornar

Protocolo 204 (NO CONTENT)
- algo ocorreu certo mas não retorno nenhum conteudo

Depotente e Idepontente			[ 5:15 ] 

// --- 11 --- // - PUT

Padrão em retornar o BAD_REQUEST permanece

PUT
- substituir o estado inteiro do objeto
- envia o objeto e esse objeto deve substituir completamente o existente

Retorna um NO CONTENT pois você já tem os dados

// --- 12 --- //

Colocar o MySQL nas dependências do pom.xml

// --- 13 --- // 

@Entity
- transformar a classe em uma tabela

@Id
- informar ao Spring que é um ID

@GeneratedValue(strategy = GenerationType.IDENTITY)
- o Id ser auto-incrementável ao salvar no banco de dados



Configurações para conexão com o banco de daos MySQL:



spring:
  datasource:
    url: jdbc:mysql://localhost:3306/animal?useSSL=false&createDatabaseIfNotExist=true&useTimezone=true&serverTimezone=UTC
    username: root
    password: paraquesenha
  jpa:
    show-sql: true 
    hibernate:
      ddl-auto: update



url: jdbc:mysql://localhost:3306/animal?useSSL=false&createDatabaseIfNotExist=true&useTimezone=true&serverTimezone=UTC
- /animal - nome da base de dados (MySQL Workbench)
- useSSL - relacionado a certificado
- useTimeZone... - relacionado a problemas com fuso horário 


show-sql: true 
- mostrar Query SQL no Consoloe quando a aplicação rodar


ddl-auto: update
- toda vez que iniciar a aplicação o banco será atualizado

// --- 14 --- // 

JpaRepository
- conectado com o banco de dados
- já vem com métodos, portanto basta só fazer o "extends"
- ao extendê-lo, automaticamente a classe já é identificada como um Spring bean

!!!!!! Não deve usar as classes que são tabelas no banco de dados (que usam @Entity) como valores de @RequestBody diretamente no Controller !!!!!!	[ 2:55 ]

Padrão DTO
- representar essa classe para substitui-la nesse @RequestBody...
...nesse caso é utilizado uma coisa um pouco diferente de DTO...
...poderia se criar um sub-classe pra representar essa classe "Animal", mas como terá SÓ esse classe "Animal", não precisa

AnimalPostRequestBody
- basicamente é uma classe DTO (mas não é exatamente uma)
- se faz nessa classe exatamente o que se faria se tivesse um DTO ou qualquer outro tipo de padrão
- o POST não precisa do valor Id, o @Data já cuida disso
- essa classe facilita refatoração ou até mesmo compartilhar serviços como se fosse um contrato	

@Builder
- construir um objeto de um jeito diferente

return animalRepository.save(Animal.builder().name(animalPostRequestBody.getName()).build()); 
- Animal.builder().name(animalPostRequestBody.getName()).build()); // mesma coisa de ----> Animal animal = new Animal(null, animalPostRequestBody.getName());
- por padrão o "save()" vai salvar o objeto e retornar esse objeto já com um Id que foi auto-incrementado

// --- 15 --- //

Essa aula é sobre trocar aqueles métodos de build(), etc, por esse framework Mapstruct para agilizar e ter melhor performance

Pode colocar todos os Mappers dentro de um pacote só      OU     Pode criar vários pacotes separados
- varia de pessoa pra pessoa

(componentModel = "spring") 	[ 3:52 ]
- possibilitar fazer injeção de dependência caso seja preciso

classe AnimalMapper 	[ 4:35 ] 
- os métodos irão fazer automaticamente a conversão de todos os atributos que se tem dentro do objeto da classe DTO para um objeto da classe (associado a uma tabela)...
... nesse caso a classe DTO "AnimalPost.. e AnimalPut.." para a classe de entidade "Animal"

public static final AnimalMapper INSTANCE = Mappers.getMapper(AnimalMapper.class);
- forma de chamar esse métodos abstratos 
- ou seja, é uma instancia dessa 

// --- 16 --- //

É usado o @RequestParam para não causar ambiguidade, já que o @GetMapping está em dois métodos

@RequestParam
- usado para inserir valores nos parâmetros do método
- funciona colocando o sinal "?" depois do caminho da URL e em seguida o parâmetro "name=" e o valor desse parâmetro "Rottweiler"
Ex: ../find?name=Bulldog

@RequestParam(defaultValue = "")
- valor padrão caso não seja passado nenhum valor na URL

@RequestParam(required = false)
- não é mais obrigatório colocar valores valores em atributos, ou seja, pode colocar somente o caminho "/find", por exemplo, sem ter que colocar o "?name=..."

// --- 17 --- //

O tratamento de exceções é mais uma questão de padrão do projeto

@ResponseStatus(HttpStatus.BAD_REQUEST)
- retorne sempre o status HTTP - Bad Request (400) 

// --- 18 --- // 

Handler Global para as exceções do projeto

A parte de consitência é a parte mais importante quando se desenvolve uma aplicação

Fazer com o que possamos manipular o retorno de informações das exceções, ou seja, deixando de um jeito padronizado

Falar para todos os Controllers que quando se tiver uma exceção do tipo BadRequestException (exceção customizada), irá precisar utilizar o método__________...

@ControllerAdvice
- avisar para todos os Controllers que devem utilizar o que se colocar dentro da classe baseado em como se fosse uma "flag"
- a flag que será utilizada é a @ExceptionHandler

@ExceptionHandler(BadRequestException.class) 	 [ 3:10 ]
- caso seja lançado uma exceção desse tipo (BadRequestException) deve-se utilizar o método que essa Annotation se refere (e retornar um valor)...
... nesse caso o valor que está sendo retornado é um objeto do tipo "ResponseEntity<BadRequestExceptionDetails>" com detalhes do erro

// --- 19 --- //

Usar TRANSAÇÕES - depende de como seu banco de dados está estruturado

Caso o engine do seu banco de dados não for "InnoDB", significa que ele não tem suporte para transações

Então, se há uma situação que você precisa checar se suas ações, em caso de exceção, precisaram de um rollback use @Transactional

@Transactional
- o Spring não vai commitar uma transação enquanto o método não for finalizado (chegar no final)
- leva em conta somente Exceções tipo Unchecked (Runtime)

@Transactional(rollbackFor = Exception.class)
- agora também leva em conta exceções Checked (Exception) e Unchecked (Runtime)

// --- 20 --- //

@Column(nullable = false)
private String name;
- isso não atualiza o banco de dados, teria que ser manualmente, então não será utilizado

Será utilizado o pacote do Spring - SpringBoot Starter Validation (antes fazia parte do Spring mas foi separado)

Como não se está utilizando a classe entidade "Animal" direto  nos Controllers, usar os Validations nas classes DTO

@NotEmpty(message = "The animal name cannot be empty")
private String name;
- significa que esse atributo ao ser salvo no banco de dados não pode ser vazio nem nulo
- (foi somente na classe AnimalPostRequestBody)

Existem outras validações de campo que podem ser feitas com esse pacote, por exemplo:
- @URL
- @Min / @Max (numero)
- ...

@Valid
- dizer para o Spring para fazer estas validações automaticamente

Dessa forma foi possível fazer validações dos campos diretamente no Controller, então nem precisa se preocupar em fazer "if" que o Spring já tomará conta

// --- 21 --- //

Fazer com o que a classe "BadRequestExceptionDetails" seja a mesma para praticamente todas as exceções, só especializando conforme necessidade

@SuperBuilder
- para classes que serão extendidas e que extendem

Criar uma classe que vai trabalhar com os campos adicionais (geradas automaticamente) que se tem quando uma exceção @Valid é lançada...
... na qual esse @Valid é para conferir o valor dos atributos (se não é empty nem null) quando há o salvamento (POST) de novos objetos no banco de dados

final		[ 3:00 ]
- pois só há o @Getter e o @SuperBuilder

Handler
- forma de uma classe fazer o Controller interceptar as exceções e adicionar na exceção o que se definir no método referido...
... e que nesse caso será lançada uma exceção personalizada (bonitinha) do @Valid que antes era automática (monstruosa)

Descobrir qual exceção é lançada quando o objeto, ao tentar salvá-lo (POST) no banco dados, é empty ou null		[ 3:30 ] 	

...collect(Collectors.joining(", "));
- caso tenha mais de um campo/atributo na stream, separá-los por ", "

Dessa forma conseguimos padronizar as exceções para validação de campos

// --- 22 --- //

protected ResponseEntity<Object> handleExceptionInternal(...)
- método responsável por montar praticamente o corpo de todas as exceções (mensagens de erro) do Spring...
... onde essas exceções são as classes que são lançadas e que estão inseridas internamente na Annotation @ExceptionHandler

Iremos sobrescrever (@Override) esse método principal com um corpo personalizado, parecido com os que criamos

@Override
protected ResponseEntity<Object> handleMethodArgumentNotValid(...)
- como esse método já era tratado pelo Spring, apenas fizemos o @Override dele e um pequeno ajuste

Dessa forma conseguimos tratar ainda mais exceções e obtendo uma padronização ainda maior no projeto

// --- 23 --- //

Paginação
- uma das coisas mais comuns quando se está trabalhando com qualquer tipo de API...
... pois você não quer 	retornar todos os dados de uma vez só para seu front-end ou mobile que faz as chamadas para o back-end

A Paginação oferece uma grande flexibilidade para quem quer que esteja consumindo sua API...
... principalmente se você estiver desenvolvendo aplicações que serão consumidas pelo mobile...
... pois você não quer retornar uma lista com 600 nomes, ou até mais, tudo de uma vez kkkkk

// --- 24 --- //

Objetivo da aula é como trocar o padrão do tamanho das Páginas retornadas...
... ou seja, ao invés fazer isso através da requisição na URL, configurar o retorno das páginas no próprio Spring

Será feito uma pequena adição que vamos criar que afetará o Spring como um todo, ou seja, criar uma nova configuração

Para a configuração ser aplicada globalmente colocar a Annotation @Configuration

pageHandler.setFallbackPageable(PageRequest.of(page, size));
- page: a página que vai ser exibida por padrão.			
Ex: tem 3 páginas (0 - 2), caso seja - page=1 - a segunda página será exibida por padrão

- size: a quantidade de dados retornados em uma página		
Ex: tem 10 dados no banco de dados, caso seja - size=5 - os dados serão divididos em 2 páginas retornando 5 dados em cada página

Dessa forma que se faz uma configuração global para sobrescrever a configuração já existente do Spring 

// --- 25 --- //

Por padrão ao adicionar o Pageable, já pode-se utilizar o método/parâmetro [ sort ]
Ex: localhost:8080/animais?size=20&sort=name,asc

Lembrando que todas as requisições, salvamentos, etc.. estão sendo feitas no nível do banco de dados e não no nível da aplicação

O Hibernate, no console, está imprimindo o log SQL fora do padrão quando é um log Spring
- isso acontece pois quando se utiliza o [ show-sql: true ] nas configurações...
... simplesmente será impresso diretamente o SQL no console sem utilizar nenhum tipo de Appender (Spring usa o Logback - log padrão do console)




logging:
  level:
    org:
      hibernate:
        SQL: DEBUG
        
        
Com essas novas configurações, o SQL agora faz parte do Logback padrão do Spring
E além deixar mais organizado, melhora a performance ao invés de só imprimir o SQL no console

// --- 26 --- //

Quando está se desenvolvendo uma aplicação em algum você precisará fazer uma requisição para um serviço/url externa...
... então o Spring disponibiliza uma biblioteca que fará essa chamada para o serviço externo, fazendo automaticamente o mapeamento dos dados para sua classe


new RestTemplate().getForEntity("http://localhost:8080/animais/2", Animal.class);
- executando um GET
- Animal.class: como a requisição irá retornar um JSON, eu falo para o Spring para tentar fazer mapeamento automaticamente usando o próprio Jackson...
... e esse [ Animal.class ] significa o qual o tipo para fazer esse mapeamento
- retornará o objeto e mais algumas informações extras que podem ser pertinentes no desenvolvimento do projeto


Caso queira pegar somente o objeto em si (body) sem as informações extras, faça:
- new RestTemplate().getForEntity("http://localhost:8080/animais/2", Animal.class).getBody();
ou
- new RestTemplate().getForObject("http://localhost:8080/animais/2", Animal.class);


Essas requisições podem ser usadas também com um ou mais placeholders (placeholders são substituidos pelos valores na ordem que são colocados):
- new RestTemplate().getForEntity("http://localhost:8080/animais/{id}", Animal.class, 2);
ou
- new RestTemplate().getForObject("http://localhost:8080/animais/{id}", Animal.class, 2);

// --- 27 --- //

Não entendi muito bem - criando outro endpoint não paginável		[ 0:20 - 2:10 ]
- talvez seja para que o retorno dos objetos sejam simples e facilitar a conversão do Array para List ao retornar a List automaticamente

Para fazer o mapeamento automático dos dados de uma coleção, faça:
- Animal[] animais = new RestTemplate().getForObject("http://localhost:8080/animais/all", Animal[].class);				(objeto "animais" é um array e não uma list)

Não aconselhável converter manualemente esse Array para List pois estaria fazendo um Cast, então pode-se utilizar o Super Type Token

Super Type Token
- fará essa conversão de Array para List automaticamente

E com o RestTemplate esse Super Type Token se dá através do método "exchange()" (flexibilidade) com o "new ParameterizedTypeReference<>()"	


ResponseEntity<List<Animal>> exchange = new RestTemplate().exchange("http://localhost:8080/animais/all",
				HttpMethod.GET,
				null,
				new ParameterizedTypeReference<List<Animal>>() {});
- null: pois não será enviado nada, é apenas uma requisição GET
- retornar lista automaticamente


Requisições do RestTemplate:
- array - getForObject()
- lista - new ParameterizedTypeReference<>()

// --- 28 --- //

POST é praticamente quase a mesma do GET

O método "exchange()" retorna um objeto dentro de um Wrapper (que é o ResponseEntity<> com aquelas infos extras que podem ser pertinentes) 

new RestTemplate().postForObject("http://localhost:8080/animais", shihtzu, Animal.class);
- shitzu: objeto criado para salvar no banco de dados
- Animal.class: o tipo que será retornado quando houver esta requisição POST


ResponseEntity<Animal> pitbullSaved = new RestTemplate().exchange("http://localhost:8080/animais",
				HttpMethod.POST,
				new HttpEntity<>(pitbull), 
				Animal.class);
- new HttpEntity<>(pitbull): o objeto que será enviado na requisição POST para salvá-lo no banco de dados
- Animal.class: o tipo que será retornado quando houver esta requisição POST


private static HttpHeaders createJsonHeader() {
- enviar um header dizendo que o Content-Type é um application Json (informações extras retornadas - Wrapper)

// --- 29 --- //

PUT e DELETE retornam Void em uma requisição
E os dois são bem parecidos em questão de código

ResponseEntity<Void> pitbullUpdated = new RestTemplate().exchange("http://localhost:8080/animais",
				HttpMethod.PUT,
				new HttpEntity<>(animalToBeUpdated, createJsonHeader()), 
				Void.class);
- ResponseEntity<Void> e Void.class: pois a requisição PUT retorna Void, ou seja, não retorna nada


ResponseEntity<Void> pitbullDelete = new RestTemplate().exchange("http://localhost:8080/animais",
				HttpMethod.DELETE,
				null,
				Void.class, 
				animalToBeUpdated.getId());
- null: pois não está enviando nenhuma entidade/objeto/dado (mais ainda sim pode-se colocar os headers - caso seja necessário autenticação)
- ResponseEntity<Void> e Void.class: pois a requisição DELETE retorna Void, ou seja, não retorna nada


ResponseEntity
- para ter o número do protocólo HTTP referente as requisições feitas e outros dados extras

// --- 30 --- //

TESTES UNITÁRIOS DEVEM FAZER PARTE DA SUA APLICAÇÃO
- seja no trabalho
- entrevista de emprego
- projetos pessoais

Para os testes utilizaremos o banco de dados em memória H2
- banco de dados que é criado assim que a aplicação se inicia e destruído assim que ela se encerra


@DisplayName("")
- trocar o nome padrão do teste (o nome da classe) por outro


Para rodar os testes não é necessário ter a aplicação SpringBoot rodando

Não está sendo testado o banco de dados em si, mas sim o repositório da aplicação pra ver se está tudo ok...
... e ver se as Querys estão funcionando da forma que se espera
(O ideal mesmo seria testar exatamente o banco de dados que se está desenvolvendo a aplicação)


@Autowired em caso de testes pode ser utilizado normalmente


Há convenções de (7 ou 8 opções) de como normear testes, mas aqui será a modo DevDojo
- nomear o método (o que será testado_o que esse método deve fazer_quando fazer)


Assertions.assertThat(animalSaved).isNotNull();
- verificar se o objeto não é null

Assertions.assertThat(animalSaved.getId()).isNotNull();
- verificar se o banco de dados criou corretamento o Id, e ele não é null

Assertions.assertThat(animalSaved.getName()).isEqualTo(animalToBeSaved.getName());
- verificar se o valor salvo foi igual ao que foi pedido para ser salvo

// --- 31 --- //

Teste de Update:
void save_UpdatesAnimal_WhenSuccessful() {


Teste de Delete:
void delete_RemovesAnimal_WhenSuccessful() {


Teste de FindById:
void findByName_ReturnsListOfAnimal_WhenSuccessful() {


Se quiser fazer diferença na entrevista de emprego trabalhe com casos que não estão explicitamente visíveis


Teste de FindByName retorna lista vazia:
void findByName_ReturnsEmptyList_WhenAnimalIsNotFound() {
- método criado para garantir que seja retornado uma lista vazia (e não null) quando um objeto procurado não for encontrado


A classe "Assertions" verifica e da um "ok" os dados cumpram/sejam aquilo escrito na expressão...
... ou seja, é aquilo que se espera que aconteça

Então caso alguém modifique o comportamento dos métodos de repositório, o Assertions avisará

// --- 32 --- //

Assertions.assertThat(animais)
				.isNotEmpty()
				.contains(animalSaved);
- encadeamento de asserções para um código mais conciso


@NotEmpty(message = "The animal name cannot be empty")
private String name;
- camada extra de segurança


Teste de exceção Post:
- há 2 modos de testar qual exceção é lançada por um método:

1)		[ 2:08 ]
Assertions.assertThatThrownBy(() -> this.animalRepository.save(animal))
		.isInstanceOf(ConstraintViolationException.class);

2)		[ 4:25 ]
Assertions.assertThatExceptionOfType(ConstraintViolationException.class)
		.isThrownBy(() -> this.animalRepository.save(animal))
		.withMessageContaining("The animal name cannot be empty");
		

Ter o diferencial de fazer testes da aplicação para as entrevistas de emprego
E que tenham testes que cubram casos não explícitos (mais um diferencial)

// --- 33 --- //

Testes Unitários do endpoint (Controller)

@Spring
- uma das formas de se fazer testes unitários
- o problema dessa Annotation é que irá inicialzar o contexto do Spring (startar a aplicação)...
... e caso o banco de dados não estiver rodando, a aplicação irá falhar

Então será usado @ExtendWith

@ExtendWith(SpringExtension.class)
- quer dizer que queremos utilizar o JUnit com o Spring
- contexto gerado mais rápido e não é totalmente inicializado

Então para começar a fazer testes unitários no Controller precisa-se implementar 2 Annotations
- @InjecMocks
- @Mock

@injectMocks
- utilizado para quando se quer testar a classe em si

@Mock
- mockar todos os objeto das classes que estão sendo utilizadas na classe declarada na Annotation @InjectMocks
- então, para não ter que inicializar em si todas essas classes, fazemos o Mock do comportamento...
... ou seja, definir o comportamento dessas classes			[ 2:40 ]

Centralizar comportamentos em um pacote "utils"

A classe "AnimalCreator" será responsável por criar todos os objetos que serão utilizados nas classes de teste (Mock)
Esses objetos são uma simulação como se tivessem sendo retornados pelo "animalService", pois não há o banco de dados...
... já que estamos apenas TESTANDO a classe "AnimalCOntroller"


private Animal createAnimalToBeSaved() {
- significa que quando chamar esse método sei que é um objeto animal que não tem Id

private Animal createValidAnimal() {
- significa que quando chamar esse método sei que esse objeto animal tem um Id valido

private Animal createValidUpdatedAnimal() {
- significa que quando chamar esse método sei que esse objeto animal tem o mesmo Id mas o nome é diferente


Para simular o comportamento de um "animalService" foi usado a Annotation @BeforeEach para criar uma lista que contém um objeto dentro dentro de um Page...
... assim simulando um [ animalService.listAll(pageable); ]

@BeforeEach
- executa o método sempre antes de todos os outros métodos

BDDMockito.when(animalServiceMock.listAll(ArgumentMatchers.any()))
			.thenReturn(animalPage);
- significa que, quando o objeto "animalController" ao executar o método "listAll()" do objeto "animalServiceMock"...
... será retornado o objeto "animalPage"


Assertions.assertThat(animePage.toList().get(0).getName()).isEqualTo(expectedName);
- para pegar os atributos de um Page, primeiro precisa-se convertê-lo para List

O objeto "dateUtil" da classe "AnimalController" é dado como null na classe de teste "AnimalControllerTest" por não estar Mockado na mesma...
... assim fazendo com o que a aplicação falhe 
Há 2 soluções:
- mocka-lo
- injetar dependência desse objeto na classe "AnimalController"
- removê-lo 

// --- 34 --- //

Para testes simulando erro (ADCASES), é bom sobrescrever os Mocks (que são feitos no @BeforeEach) no próprio escopo do teste		[ 7:20 ]


public class AnimalPostRequestBodyCreator {

	public static AnimalPostRequestBody createAnimalPostRequestBody() {
			return AnimalPostRequestBody.builder()
					.name(AnimalCreator.createAnimalToBeSaved().getName())
					.build();

- criou-se a classe "AnimalPostRequestBodyCreator" e esse método "createAnimalPostRequestBody()" pois são para os testes da classe "AnimalController"...
... já a classe "AnimalCreator" e seus métodos são para o testes da classe "AnimalRepository"



public class AnimalPutRequestBodyCreator {

	public static AnimalPutRequestBody createAnimalPutRequestBody() {
		return AnimalPutRequestBody.builder()
				.id(AnimalCreator.createValidUpdatedAnimal().getId())
				.name(AnimalCreator.createValidUpdatedAnimal().getName())
				.build();

- criou-se a classe "AnimalPutRequestBodyCreator" e esse método "createAnimalPutRequestBody()" somente para preencher o parâmetro...
... já que quando for executado método "replace" do Mock "animalServiceMock" (no @BeforeEach), o método não fará absolutamente nada...
... ocasionando sempre, independentemente, no retorno "ResponseEntity<Void>" do método "replace" da classe testada "AnimalController"


Testes com resultado esperado: 		-Caso de sucesso
Testes simulando erro: 				-Adcases

// --- 35 --- //

Testes Unitários do Service

// --- 36 --- //

Testes de Integração - próximo nível de testes (testes do Controller)
- são teste onde a aplicação inteira é executada
- testes como se estivesse no deploy em produção

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
- inicializa e utiliza uma porta aleatória toda vez que os testes dessa classe forem executados...
... colocando a porta = 0, assim o Tomcat por padrão iniciará em uma porta aleatória
- para não utilizar a porta padrão 8080, pois talvez alguma outra aplicação já esteja usando essa porta

@LocalServerPort
private int port;
- forma de pegar a porta que está sendo utilizada no momento da execução

Porém o objeto "testRestTemplate"
- por padrão sabe onde está localizado (classe) - onde está o localhost e a porta

@AutoConfigureTestDatabase
- executar os testes dessa classe em um banco de dados em memória



PROBLEMA: com o teste do método "list()" da classe "AnimalController"
- "Page" é um objeto que não podemos criar

ResponseEntity<PageImpl<Animal>> exchange = testRestTemplate.exchange("/animais", HttpMethod.GET, null,
				new ParameterizedTypeReference<PageImpl<Animal>>() {});
- mesmo que na classe "AnimalController" haja o método "list()" que retorna um objeto tipo "ResponseEntity<Page<Animal>>"...
... colocou-se o retorno como um objeto "PageImpl<Animal>" pois esse objeto é uma implementação de "Page", já que "Page" é uma interface
- porém, mesmo com isso tudo, quando o código é executado há o erro de que o objeto "PageImpl" não pode ser criado por não haver um construtor...
... pois o Jackson não conseguiu fazer a conversão para esse tipo

SOLUÇÃO: criar uma classe "PageableResponse", é um Wrapper para objetos tipo "PageImpl<T>"	 	[ 5:35 ]
- esta classe faz o Wrapper do que é retornado no objeto acima "PageImpl<Animal>"
- estende a classe "PageImpl<T>" para fazer o Wrapper



Animal savedAnimal = animalRepository.save(AnimalCreator.createAnimalToBeSaved());
- vai salvar o animal no banco de dados em memória (de teste)

Obs: Durante estes testes SOMENTE A CLASSE "AnimalControllerIT" foi executada e não a aplicação em si
Portanto, caso a aplicação em si for executada, as requisições ainda estão sendo feitas na porta 8080 normalmente como antes

// --- 37 --- //

1) Unit Tests
2) Integration Tests
3) UI Tests (não considerado para este projeto)

Mesmo que não faça tanta diferente retirar o modo DEBUG se otimiza, em aplicações maiores, o tempo de desenvolvimento 		[ 0:17 - 2:30 ]

Integrando todos os métodos a serem testados, sendo esses testes locais rodando apenas a classe "AnimalControllerIT" 	[ 2:45 ]

É interessante manter um teste de HttpStatus para ter certeza que estamos mantendo o padrão em toda a API		[ 10:30 ]

utilizar o método "exchange" pois o método Http PUT retorna void		[ 16:25 ]

PROBLEMA: @DataJpaTest - deleta e cria um novo banco de dados em memória para cada método, testando-os unicamente...		[ 18:30 ]
... ou seja, cada método testado terá o banco de dados em memória limpo para fazer os testes sem conflito entre dados de outros métodos
... Já o @AutoConfigureTestDatabase - não faz isso

SOLUÇÃO: utilizar a Annotation @DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
- o Spring irá deletar (drop) no bando de dados em memória e recriar para cada método
- porém, note que o tempo de execução de tais testes aumenta devido à exclusão e recriação do bd em memória

Obs: agora, todos Testes de Integração de cada método estão sendo executados todos de uma vez, não mais separadamente

Testes de Intregação geramente são mais lentos, por isso que separamos ele para uma classe única pois rodam em tempos diferentes na pipeline
- não é atraente executar seu Teste de Integração sempre que fizermos alterações no código (testes levando +/- 1 segundo para serem executados...
... onde em uma empresa podem haver 1500 testes = eternidade)

Assim, com estes Testes de Integração, temos o mais prózimo possível que teríamos se fizessemos o Deploy em produção

// --- 38 --- // 

Objetivo da aula: separar o Profiles, para assim executar os testes em diferentes ciclos do Maven...
... pois, como os Testes de Integração são mais demorados que os Testes Unitários, não queremos executá-lo a todo momento

Utilizando o Maven para executar os Testes de Integração		[ 1:40 ]

<id>integration-tests</id>
- é o Profile

Configuração para que os Testes sejam executados		[ 4:00 ]

<include>**/*IT.*</include>
- executar este arquivo independente do pacote [ ** ], do nome [ * ], e do tipo deste arquivo [ .* ] e que contenha a terminação "IT"...
... onde, padronizado neste projeto, todos os Testes de Integração terminam com o sufixo "IT"

<include>**/*Test.*</include>
- dessa forma, os arquivos com o sufixo "Test" são incluídos no Profile "integration-tests", junto com os arquivos de sufixo "IT"...
... ou seja, os Testes Unitários e os Testes de Integração são testados juntos (caso você queira)

mvn test -Pintegration-tests
- digitar comando no Terminal
- -P: profile, no qual corresponde o atributo xml <id>

Estes testes demoram um tempo considerável, sendo elevado caso haja novas implementações no projeto...
... ou seja, a cada implementação incluida no repositório estes testes devem ser executados...
... em um projeto grande, dentro de alguns meses, pode levar de 2 a 3 minutos para os testes serem concluídos

A premissa é que ambos tipos de teste devem ser testados em Profiles diferentes

Obs: Nessa aula os Testes de Integração e Testes Unitários foram testados juntos

// --- 39 --- //

As primeiras coisas a se fazer ao trabalhar com Spring Security é adicionar as dependências que irão realizar a segurança da aplicação

Só de adicionar o Spring Security adquire uma segurança básica - não a melhor porque os dados serão diferentes toda vez ao reiniciar a aplicação
Console - "Using generated security password: ..."

Repara-se que, após incluir a dependência do Spring Security, uma senha é gerada. Por causa do CLASSPATH que o Spring faz o Scan...
... ou seja, lembre-se que o Spring irá utilizar "por debaixo dos panos", diversos tipos de Scanner de classes para carregar as configurações...
... Então como foi adicionado o Spring Security, existem configurações que foram carregadas na sua aplicação, dando uma segurança padrão à aplicação

Portanto, agora, para realizar requisições HTTP à aplicação (Postman), será necessário utilizar essa senha...
... E caso fizermos essa requisição sem a senha, o status 401 (Não autorizado/autenticado) será retornado

Assim, para realizar as requisições normalmente, fazemos:
1) Aba Autthorization -> Basic Auth (Postman)
2) Username = "user" (gerado por padrão)
3) Password = senha gerada ao rodar a aplicação (nova geração a cada execução)


Agora, iremos começar a costumizar a parte de segurança	- Usuário em memória		[ 3:50 ]

E no Spring precisamos ter um Bean, onde segurança é uma configuração que será carregada e será utilizada em toda a aplicação - Filtros (a forma como o Spring funciona)...
... Assim, nessa classe, será criado uma configuração que carregará automaticamente por esses filtros		[ 5:10 ]
- gerar o Spring Bean para a classe com a Annotation @EnableWebSecurity

extends WebSecurityConfigurerAdapter
- para reconhecer os Beans que trabalharemos

Sobrecarregar 2 métodos "configure"	para configurações de segurança		[ 6:15 ]
- 1° método: protegendo as requisições HTTP
- 2° método: adicionando usuários em memória para autenticação



/ 1° método - protegendo requisições HTTP / 

Proteger tudo - sempre que a aplicação receber uma requisição HTTP, este método com funções serão executadas

Ex: 

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests()
				.anyRequest()
				.authenticated()
				.and()
				.httpBasic();
	}
- ou seja, para todas as requisições HTTP (as URL's do Controller) vão precisar passar por autenticação básica



/ 2° método - Autenticação com Usuário em memória / 

Usuário em memória - os usuários que ficarão ativos duranto o ciclo de vida da aplicação...
... e, ao reiniciar a aplicação, senhas serão sempre as mesmas, porém, com codificações diferentes

Um usuário em memória precisa ter um tipo de criptografia para sua senha
DICA: não fazer uma senha sem números

Note que agora aquele password não está mais sendo gerado automaticamente (no log), pois agora temos configurando o Gerenciador de Autenticação...
... ou seja, o objeto "AuthenticationManagerBuilder" do método "configure"

Ex: 

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
		log.info("Password encoded {}", passwordEncoder.encode("test"));
		
		auth.inMemoryAuthentication()
				.withUser("rique")
				.password(passwordEncoder.encode("academy"))
				.roles("USER", "ADMIN")
				.and()
				.withUser("devdojo")
				.password(passwordEncoder.encode("academy"))
				.roles("USER");
	}
- log.info..: apenas para mostrar no log o funcionamento da senha codificada através do objeto "passwordEncoder"
- withUser(): o nome do usuário
- password(): a senha do usuário codificada
- roles(): as permissões desses usuários

( Postman - ao colocar a senha certa uma vez, ela ficará salva nos cookies, e por isso ao colocar uma senha errada, ela funciona )

Então, o Basic Auth são usuário e senha condificados (Basic64 encode)
Assim, se fornecermos o Token desse basic Auth, a aplicação poderá ser acessada por qualquer pessoa...
... e por isso que existe que chamamos de "ciclo de vida de um Token" em que precisamos obrigatóriamente fazer o Token expirar ou uma seção expirar...
... senão quem ter acesso àquele Token poderá fazer qualquer coisa na aplicação até o desenvolvedor trocar a senha


// --- 40 --- // 

[ 0:30 ]
Mesmo que estejamos autenticados com login e senha corretos, como não estamos utilizando nenhum tipo de 'Role' o que estpa falhando é a parte de CSRF...

CSRF - Cross-site request forgery: que resumidamente é quando alguém executa uma ação em seu nome 		[ 1:10 ] Assistir!!!

O Spring oferece suporte por padrão ao CSRF que pode ser desabilitado. E após desabilitá-lo, o método HTTP "POST" funciona normalmente - status 201...

Ex:

	csrf().disable()...



Mas queremos criar um TOKEN por questões de segurança. E para criar um TOKEN ao invés de desabilitar utilizamos alguns métodos:

Ex: 
	
	csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()).and()...
- withHttpOnlyFalse(): o utilizamos pois quando se manda um cookie que se coloca essa flag "HttpOnly" com o valor "true", as aplicações front-end em JavaScript / React / Angular...
... não consiguirão pegar o valor desse cookie. E quando estão fazendo uma requisição POST eles também precisam passar esse cookie quando o CSRF está desabilitado


Utilizar o método HTTP "GET" para recuperar o valor do Token gerado para utilizarmos os métodos HTTP "PORT" normalmente 	[ 4:20 ]

Os métodos HTTP "GET" por padrão não têm o status do servidor assim não precisando do CSRF Token

Postman - quando a aplicação é exectuada, um novo CSRF Token é gerado. E para automatizar a obtenção desse CSRF Token, fazemos		[ 5:35 ]

[ 8:19 ]
E para facilitar a vida e o curso ter o intuito de deixar as coisas mais simples, simplesmente desabilitaremos o CSRF...
... mas caso estivermos desenvolvendo uma aplicação em produção, deve-se lembrar de utilizar o CSFR Token

Postman - desabilitando o CSFR Token, toda a automatização édeixada de lado, sendo necessário apenas a "Basic Auth" para interação com a API (aplicação)

// --- 41 --- //

@PreAuthorize
- utilizado em endpoints para autorizar apenas usuários que tiverem 'roles' específicas/necessárias determinadas nesses endpoints...
... ou seja, para um usuário salvar um novo animal, por exemplo, ele terá de ter a 'role' "ADMIN"

Neste momento, a aplicação apenas com a autorização básica de "usuário" e "senha" o usuário consegue consumir a API...
... porém, agora, utilizaremos o "PreAuthorize" para o POST, sendo apenas o usuário com a 'role' "ADMIN" podendo utilizar o método HTTP "POST" (salvar)

Ex: 

	@PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Animal> save(@RequestBody @Valid AnimalPostRequestBody animalPostRequestBody) {
    	return new ResponseEntity<>(animalService.save(animalPostRequestBody), HttpStatus.CREATED);
    }
- apenas usuários com a 'role' "ADMIN" poderão consumir a API...
... na qual essa 'role' é determinada no método "configure(AuthenticationManagerBuilder" na classe "SecurityConfig"

Porém, ainda falta declarar ao Spring para habilitar as Annotations que são para pré e POST com a Annotation @EnableGlobalMethodSecurity		[ 1:40 ]

Obs: Há a Annotaion "@PostAuthorize", mas que não foi utilizado..

Ex: 

	@EnableGlobalMethodSecurity(prePostEnabled = true)
	public class SecurityConfig extends WebSecurityConfigurerAdapter {
- prePostEnabled: por padrão é "false"


[ 2:50 ]
Após declarar o @EnableGlobalMethodSecurity é gerada uma senha automatica no log - porém não há preocupação pois...
... sobrescrevemos o método  "configure(AuthenticationManagerBuilder" na classe "SecurityConfig", assim não tendo nenhum efeito

Dessa forma, para exececutarmos o método HTTP "POST" de salvamento, precisa-se estar autenticado e ter a 'role' necessária deste endpoint

// --- 42 --- //

Nessa aula será abordado como recuperar o usuário que está autenticado em requisições da API

""Duplicando"" um método para não ter que ajustar todos os testes por causa de um novo parâmetro		[ 0:30 ]

@AuthenticationPrincipal
- Annotation utilizada no parâmetro do endpoint que recupera os dados do usuário autenticado que está consumindo a API

E para fazer essa recuperação de dados, faz-se:

 Ex:
 
 	public ResponseEntity<Animal> findByIdAuthenticationPrincipal(@PathVariable long id, 
    															  @AuthenticationPrincipal UserDetails userDetails) {

[ 2:10 ]
Atributo "password" é "null" para não ser tão fácil assim de se conseguir a senha		
Podemos adicionar mais dados no objeto de "UserDetails"		[ 3:00 ]

[ 3:15 ] Assistir em diante!!!

Para utilizar uma página de login padrão do próprio Spring:

Ex: 

	.formLogin()
	.and()


O Spring tem vários filtros (classes):
- BasicAuthenticationFilter: verificar se você tem uma autenticação do tipo Basic64 encoder
- UsernamePasswordAuthenticationFilter: verificar se na requisição há o "user" e a "password"
- DefaultLoginPageGeneratingFilter: página que gera o login
- DefaultLogoutPageGeneratingFilter: página que gera o logout
- FilterSecurityInterceptor: verifica se você está autorizado

Lembrando, há 2 processos quanto a segurança, Authentication ---> Authorization
- Authentication: login - user e password
- Authorization: permissão - 'roles'

// --- 43 --- //

Nessa aula será abordada a questão de usuário e sua autenticação no banco de dados, assim como em memória

Criar uma classe que represente o usuário na classe "entities"
- o nome da classe não é simplesmente "User" pois há alguns banco de dados que dão xabu quando se tenta criar uma tabela com esse nome...
... mas consideramos essa classe como uma classe geral para Usuários

Para manter as coisas simples para o projeto, não será utilizado a Annotation do JPA - Hibernate @Table 

Utilizar um funcionamento do Spring para garantir que esse objeto "DevDojoUser" fará parte da @AuthenticationPrincipal...
... no objeto "userDetails" na classe de Controller que é implementar a interface "UserDetails"
- por causa da regra de Polimorfismo, poderemos utilizar o @AutheticationPrincipal para recuperar o valor definirmos no objeeto classe "DevDojoUser" 

Os métodos implemetados poderiam receber o valor "true" do banco de dados, mas estamos inserindo-o diretamente
- esses métodos retornando "true" teremos certeza absoluta que pelo menos a conta funcionará sem nenhum outro problema caso o usuário esteja correto

A parte de Authorities depende como você está desenvolvendo seu sistema, o seu Desing de sistema
- mas nesse caso colocaremos essas Authorities separadas por "," - método da "getAuthorities"... // ROLE_ADMIN, ROLE_USER
...  mas poderíamos fazer isso por uma coluna, uma abela, até mesmo um banco separado só pra colocar a parte de Authorities

No método "getAuthorities":

Ex: 

	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		return Arrays.stream(authorities.split(","))
				.map(SimpleGrantedAuthority::new)
				.collect(Collectors.toList());
	}
- transformando o Array de 'roles', ou seja, as Authorities, para novos objetos de tipo "SimpleGrantedAuthority"


[ 4:27 ]
Na parte de configuração do método "configure(AuthenticationManagerBuilder... na classe "SecurityConfig"":

Ex: 

	auth.userDetailsService()..
	
- objetos "UserDetailsService" está por toda a parte de segurança do Spring...
... então, através do Polimorfismo, o Spring saberá chamar o método "findByUsername"



Então, para autenticarmos algo no método "userDetatilsService" acima, precisamos criar algo que o sistema irá reconhecer...
... ou seja, criar uma classe que implemente a interface "UserDetailsService" provendo a implementação do método "loadUserByUsername"

[ 5:40 ]
Criar uma interface Repository "DevDojoUserRepository", referente a classe de usuário, recuperando os dados para autenticação do banco de dados
- se tivesse um email ou algo do tipo era somente implementar esse método na classe 

[ 6:30 ]
Criar uma classe Service "DevDojoUserDetailsService", para a autenticação no método "configure(AuthenticationManagerBuilder..." da classe "SecurityConfig"
- assim que esse método "configure" for executado, chamando esse objeto de tipo "DevDojoUserDetailsService"...
... o método implementado sobrescrito "loadUserByUsername" será executado recuperando o usuário  no banco de dados...

Agora, depois de criado as classes (e interface) necessárias, como "DevDojoUser", "DevDojoUserRepository" e "DevDojoUserDetailsService", iremos autenticar...
... método "configure(AuthenticationManagerBuilder..." da classe "SecurityConfig"

Ex: 

	auth.userDetailsService(devDojoUserDetailsService).passwordEncoder(passwordEncoder);
	
- passwordEncoder(passwordEncoder): como estamos buscando o "loadByUsername", a autenticação precisa comparar a senha, na qual está codificada...
... e dessa forma estamos dizendo ao Spring como essa senha foi codificada (com o objeta da classe codificadora), sendo codificada no padrão "bcrypt"



[ 10:25 ]
Notar que precisamos criar os usuários no banco de dados
- para redigir a senha no banco de dados, precisamos primeiro encriptografá-la = pegamos a senha codificada no log também incluindo a string "{bcrypt}":

Ex: 
	
	PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
	log.info("Password encoded {}", passwordEncoder.encode("academy"));
	
	

[ 13:46 ]
A parte de configuração do Spring suporta multipla autenticação com diferentes tipos do que chamamos de 'providers'...
... pois imagine caso precisemos autenticar usuários de outros bancos de dados.
E como exemplo para essa multipla autenticação, também iremos inserir outros usuários, só que em memória

Ex: 

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
		log.info("Password encoded {}", passwordEncoder.encode("academy"));
		
		// autenticação de usuário em memória
		auth.inMemoryAuthentication()
				.withUser("rique2")
				.password(passwordEncoder.encode("academy"))
				.roles("USER", "ADMIN")
				.and()
				.withUser("devdojo2")
				.password(passwordEncoder.encode("academy"))
				.roles("USER");
		
		// autenticação de usuário no banco de dados
		auth.userDetailsService(devDojoUserDetailsService).passwordEncoder(passwordEncoder);
	}
- 2 pontos de entrada de usuários: 1) em memória através do "inMemoryAuthentication()" e 2) no banco de dados através do "devDojoUserDetailsService"
- o Spring faz essa autenticação na ordem, primeiro verifica se existe o usuário em memória, caso não exista, parte para busca no banco de dados, e se não achar - status 401

// --- 44 --- //

Nessa aula, será abordada proteção de URL's de uma forma um pouco diferente, utilizando 'Antmathcer'

Anteriormente, no Controller, utiizamos o @PreAuthorize (que serão removidos), mas agora começaremos a utilizar um padrão

Imagine que temos um padrão. Um padrão onde todas as URL que irão realizar uma mudança de estado no nosso servidor vão começar com um padrão, um nome específico...
... por exemplo, os métodos HTTP "POST", "DELETE" e UPDATE" começarão com um "/admin" na URL, onde o "GET" começaria diretamente com "/animais", "/animais/3" etc..
Quando se tem esse tipo de padrão é possível utilizar o que chamamos de 'Antmatchers'.

Antmatcher: trabalham com (não entendi [ 1:17 ]) protegendo suas URL's com determinadas 'roles'

No método "configure(HttpSecurity.." da classe "SecutiryConfig":

Ex: 
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable()	// csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()).and()
				.authorizeRequests()
				.antMatchers("/animais/admin/**").hasRole("ADMIN")
				.antMatchers("/animais/**").hasRole("USER")
				.anyRequest().authenticated()
				.and()
				.formLogin()
				.and()
				.httpBasic();
	}
- .antMatchers("/animais/admin/**").hasRole("ADMIN"): toda e qualquer URL depois de "/animais/admin" o usuário terá que obter a 'role' "ADMIN" 
- .antMatchers("/animais/**").hasRole("USER"): toda e qualqer URL depois de "/animais" o usuário terá que obter a 'role' "USER"
- a 'antmatcher' que tiver a 'role' mais restritiva deve vir primeiro e mais abrangente depois, pois, senão, a 'role' "USER" seria aplicada na 'role' "ADMIN"...
... já que a epressão "/**" cobriria o "/admin"
- .anyRequest().authenticated(): será mantido para, caso tenhamos outra URL que não está na parte de "/animais", o usuário ainda precise pelo menos estar autenticado

// --- 45 --- //

Nesta aula, iremos ajustar os Testes de Integração falhos devido a implementação do Spring Security nos endpoints...
... já que anteriormente os testes eram feitos sem a parte de segurança.

Apenas os Testes de Integração estão dando erro pois é executado o mais próximo possível de um ambiente de produção, como se fosse um chamada externa, via "RestTemplate"...
... mas os Testes Unitários das outras classes que não são Testes de Integração continuam funcionando pois são dados "mockados"

Existem diversas formas que podemos fazer para aplicar segurança em toda a suite de testes, mas o abordado nessa aula será o mais fácil e de maior flexibilidade (de acordo com o DevDojo)


O objeto dependência "testRestTemplate" da classe "AnimalControllerIT" não está configurado para utilizar segurança...
... portanto, precisamos criar um Bean onde será utilizado no momento do @Autowired deste objeto.
Para isso, criaremos uma classe dentro da própria classe "AnimalControllerIT" com um método...
... um método que criará um objeto  um usuário para autenticação do tipo "TestRestTemplate" para a realização das requisições nos testes:

Ex:
	
	@Autowired
	@Qualifier(value = "testRestTemplateRoleUser")
	private TestRestTemplate testRestTemplate;
	
	...
	
	@TestConfiguration
	static class Config {
		
		@Bean(name = "testRestTemplateRoleUser")
		public TestRestTemplate testRestTemplateRoleUserCreator() {
		
			RestTemplateBuilder restTemplateBuilder	= new RestTemplateBuilder().basicAuthentication("rique", "academy");
			
			return new TestRestTemplate(restTemplateBuilder);
		}
	}
	
- static: está na documentação do Spring, e sem ele dará erro no processo
- @TestConfiguration: configuração que iremos setar para a suite de testes
- basicAuthentication("rique", "academy"): autenticando um usuário como se fosse no Postman - configurado na classe "SecurityConfig"
- @Bean(name = "testRestTemplateRoleUser"): criando e nomeando um novo Bean para o objeto "testRestTemplate"...
... não utilizar um objeto do tipo "TestRestTemplate" padrão, e sim o criado no método "testRestTemplateRoleUserCreator()"
- @Qualifier(value = "testRestTemplateRoleUser"): o Bean da injeção de dependência (@Autowired) será o Bean que criamos, ou seja, o Bean com o nome "testRestTemplateRoleUser"


[ 5:35 ]
Ao tentar executar os Testes de Integração, pode-se notar que no log há o aviso de "URI is not absolute"...		
... ou seja, não temos mais acesso ao URI deste servidor (RANDOM_PORT).
E para solucionarmos este problema fazemos:

Ex:

//	@LocalServerPort
//	private int port;
	
	...
	
	@TestConfiguration
	@Lazy
	static class Config {
		
		@Bean(name = "testRestTemplateRoleUser")
		public TestRestTemplate testRestTemplateRoleUserCreator(@Value("${local.server.port}") int port) {
			
			RestTemplateBuilder restTemplateBuilder	= new RestTemplateBuilder() 
					.rootUri("http://localhost:" + port)
					.basicAuthentication("devdojo", "academy");
			
			return new TestRestTemplate(restTemplateBuilder);
			
		@Bean(name = "testRestTemplateRoleAdmin")
		public TestRestTemplate testRestTemplateRoleAdminCreator(@Value("${local.server.port}") int port) {
			
			RestTemplateBuilder restTemplateBuilder	= new RestTemplateBuilder() 
					.rootUri("http://localhost:" + port)
					.basicAuthentication("rique", "academy");
			
			return new TestRestTemplate(restTemplateBuilder);
		}
	}

- não temos acesso a Porta, ao objeto "port", por não ser um objeto estático, e não podemos inseri-lo dentro do método "rootUri()"...
- @Lazy: ... então precisamos que nossa classe estática "Config" seja inicializada depois da nossa configuração de Porta. E é por isso que utilizamos essa Annotation
- @Value("${local.server.port}") int port: para substituirmos aquele objeto "port" e podermos utilizar dentro de nosso método "testRestTemplateRoleUserCreator()" e definirmos a URI
- (poderiamos ter apenas um BasicAuthentication, e configurando-o nos próprios Testes de Integração (nos métodos) - mas da forma que estamos fazendo é mais simples)

[ 7:25 ] Assistir!!!
Status HTTP 401 porque não temos um usuário. Nós estamos passando um usuário para autenticar, mas não temos nenhum usuário salvo no banco de dados em memória para a autenticação...
... portanto, necessitamos criar e salvar um usuário mockado no bd em memória (compatível com os usuários reais cadastrados no banco de dados real e em memória - "SecurityConfig") para a autenticação nos Testes de Integração:

Ex:

	@Autowired
	private DevDojoUserRepository devDojoUserRepository;
	
	private static final DevDojoUser USER = DevDojoUser.builder()
			.name("DevDojo Academy")
			.password("{bcrypt}$2a$10$ROeCah/PSiaYJbWi4SQhoe33aH4CRL6smkW3Bp4fxbyecSgyVgviG")
			.username("devdojo")
			.authorities("ROLE_USER")
			.build();
	
	private static final DevDojoUser ADMIN = DevDojoUser.builder()
			.name("Henrique Lira")
			.password("{bcrypt}$2a$10$ROeCah/PSiaYJbWi4SQhoe33aH4CRL6smkW3Bp4fxbyecSgyVgviG")
			.username("rique")
			.authorities("ROLE_USER,ROLE_ADMIN")
			.build();

- váriaveis de objetos a serem adicionados no bd H2 para cada caso dos Tests de Integração (dos métodos, já que o bd em memória é recriado em cada um)

Adicionando os usuários no banco de dados em memória em todos os métodos 		[ 11:20 ]


Dessa forma, é adicionado no bd em memória os usuários para autenticação, e consumindo a API para testes com objetos de tipo "TestRestTemplate" com 'roles' específicas

Ex - Adicionar usuários no banco de dados em memória h2: 

	devDojoUserRepository.save(ADMIN);
	devDojoUserRepository.save(USER);


Ex - Consumir a API: 

	testRestTemplateRoleUser..
	testRestTemplateRoleAdmin..
	
[ 17:20 ]
Resumo //  
1) Criamos dois usuários que são criados e adicionados no banco de dados de memória H2 em todos os Testes de Integração (testes particulares de cada método)
2) Criamos duas configurações para o RestTemplate, que, nesse caso, são objetos para teste, então são do tipo "TestRestTemplate"...
... utilizando usuários diferentes com suas diferentes 'roles' definidas ao adicioná-los ao banco em memória

// --- 46 --- // 

***   Não será feita a parte de descrição textual de como a aplicação funciona e como está arquiteturada 	   	***
 **   Mas, deixaremos os endpoints disponíveis e os usuários saberão como o objeto precisa ser passado e etc 	**
 
Aula sobre a Documentação da API com o SpringDoc com OpenAPI.

OpenAPI: Traduzido do inglês-A OpenAPI Specification, originalmente conhecida como Swagger Specification...
... é uma especificação para arquivos de interface legíveis por máquina para descrever, produzir, consumir e visualizar serviços da Web

A Documentação é um tópico extremamente importante quando se desenvolve uma API, pois é como seu front-end / outros usuários saberão como consumir sua API

##  https://springdoc.org/  ##

Adicionando a dependência:

	<dependency>
		<groupId>org.springdoc</groupId>
      	<artifactId>springdoc-openapi-ui</artifactId>
     	<version>1.5.9</version>
	</dependency>


E ao adicioná-la, teremos acesso ao:

	# swagger-ui custom path
	springdoc.swagger-ui.path=/swagger-ui.html
	
- caminho na URL que oferece os nossos endpoints e o que precisamos passar para executar as requisições


Então, ao entrarmos na URL "localhost:8080/swagger-ui.html" e fazer o login percebemos uma Interface para o entendimento dos endpoints e sua utilização

Percebe-se que, no método "GET /animais", está sendo obrigatório (*required) o uso do Pageable como argumento, quando na verdade não deveria ser...
... E para esconder essa solicitação do Pageable podemos usar a Annotation "@Parameter" do pacote "io.swagger" no parâmetro do endpoint em questão

Ex: 
	
	@GetMapping
	public ResponseEntity<Page<Animal>> list(@Parameter(hidden = true)Pageable pegeable) {
		return ResponseEntity.ok(animalService.listAll(pegeable));
	}


Assim como o método "GET /animais/by-id/{id}" está também pedindo argumentos que não deveriam ser solicitados...
... E pensando nisso, existem mais outras duas dependências no Spring que nos ajudarão a solucionar esse problema 
- Spring Data Rest support 
- Spring security support (ajudará a ignorar o @AuthenticationPrincipal) do pacote "org.springdoc.api"


No método "GET /animais" iremos substituir o "@Parameter(hideen - true)" para "@ParameterObject", pois assim poderemos aplicar argumentos da requisição, como "page", "size" e "sort" 

E lembrando que temos um contrato para seguir ao requerir os endpoints, como utilizar os mesmos nomes das váriaveis enviadas ao salvar/atualizar um objeto...
... E é por isso que existe o versionamento de API's

