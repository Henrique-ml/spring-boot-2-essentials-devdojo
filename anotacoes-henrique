@ResponseBody <- @RestController
- o retorno dos métodos dentro da classe serão apenas Strings
- imbutido na classe annotation @RestController


Jackson 
- serializador oficial do Spring
- criar os atributos JSON utilizando os GETTERS/SETTERS (error: 500 caso não tenha os get/set)


@Component
- transformar a classe em Bean (classe escaneável) para que o Spring possa trabalhar com ela
- @Controller e @Service são (quase) a mesma coisa

@RequiredArgsConstructor
- criar um Construtor da classe com somente métodos "final"

@Configuration
- transformar a classe em um Bean
- Marca a classe como uma fonte de definições de bean para o contexto do aplicativo
- vai colocar a classe de configuração no meio do "Filter Chain" (corrente de filtros)

@EnableAutoConfiguration
- configuração de propriedades, classes a serem executadas, etc.
- Diz ao Spring Boot para começar a adicionar beans com base nas configurações do classpath, outros beans e várias configurações de propriedade...
- ...Por exemplo, se spring-webmvcestiver no caminho de classe, essa anotação sinaliza o aplicativo como um aplicativo da web
- ... e ativa os principais comportamentos, como configurar um DispatcherServlet.

@ComponentScan
- varrer os pacotes, com as classes, no pacote principal onde essa anotação estiver 
- Diz ao Spring para procurar outros componentes, configurações e serviços no com/examplepacote, permitindo que ele encontre os controladores.

Básico do Spring para se inicializar uma aplicação, escanear toda a config e os componentes
- @EnableAutoConfiguration
- @ComponentScan		
- @Configuration

@SpringBootApplication
- é uma anotação de conveniência que adiciona todos os seguintes: @Configuration / @EnableAutoConfiguration / @ComponentScan 

// --- 05 --- //

Ao inserir a dependência Spring Boot Devtools
- Spring habilitará o Hot Swap, e entre outras coisas

Hot Swap 
- fazer somente o Build de pequenas mudanças feitas no código e não precisar reiniciar a aplicação inteira
- melhor performance, menos tempo, para rodar a aplicação

// --- 07 --- //

@Data 
- gerar getters/setters, hashCode e equals, toString, ...

@AllArgsConstructor
- gerar construtor com todos os atributos







Pacotes / Classes e suas responsabilidades
- Controllers: onde são os endpoints
- Service: lógica regra de negócios
- Repositories: a conexão diretamente com o banco de dados (Query's ficarão aqui)
- Entities: o que se tem no banco de dados








// --- 08 --- // - GET

ResponseEntity<>
- retornar informações extras de uma requisição HTTP. Ex: o status da requisição
- quando a resposta da requisição retornar direitinho, sem nenhum erro, não terá nenhuma alteração no resultado

.orElseThrow()		[ 5:35 ]
- na stream, retornar algo caso não encontre o objeto pedido
- por convenção as pessoas lançam o "Error 404", mas ele não apresenta tantas informções, então fazer um padrão mais explicativo
- no código utilizar um padrão, ou seja, usou no endpoint o - HttpStatus.BAD_REQUEST - então usar em outros endpoints também

properties.application -> propoerties.yml		[ 8:12 ]
- esconder o Stack Trace na requisição GET do erro do método finById() caso não seja encontrado um animal com aquele id

// --- 09 --- // - POST

O padrão de retorno de dados é o que define (Ex: o .orElseThrow acima)

Nesse caso irá se retornar um objeto inteiro

Há muitos lugares onde quando se faz a requisição POST, pode se receber no retorno:
- ou apenas um ID e um protocolo 201 (CREATED)
- ou só o protocolo 201 sem nenhum outro tipo de retorno
- ou o objeto inteiro


O método save() precisa de um "body" = ou seja, esse requisição precisa receber um objeto e ser mapeada para salva-la
- nesse caso usar o Jackson para fazer o mapeamento

Jackson funciona assim: 
- se ele encontrar o JSON com os atributos da requisição exatamente iguais aos atributos da classe ele fará o mapeamento
- caso o atributo não esteja como o mesmo nome ele será ignorado, não será mapeado (utilizar o @JsonProperty)

@JsonProperty
- fará com o que o atributo JSON seja mapeado mesmo sendo diferente do atributo classe 
- Ex:	
		@JsonProperty("name") // como será na requisição e ser mapeado para esse atributo da classe
		private nameCharacter; 
		
@ResponseStatus("HttpStatus.CREATED")
- retornar o protocolo 201 (CREATED)

// --- 10 --- // - DELETE

Padrão em retornar o BAD_REQUEST permanece
- animais.remove(findById(id)); // findById() que irá retornar

Protocolo 204 (NO CONTENT)
- algo ocorreu certo mas não retorno nenhum conteudo

Depotente e Idepontente			[ 5:15 ] 

// --- 11 --- // - PUT

Padrão em retornar o BAD_REQUEST permanece

PUT
- substituir o estado inteiro do objeto
- envia o objeto e esse objeto deve substituir completamente o existente

Retorna um NO CONTENT pois você já tem os dados

// --- 12 --- //

Colocar o MySQL nas dependências do pom.xml

// --- 13 --- // 

@Entity
- transformar a classe em uma tabela

@Id
- informar ao Spring que é um ID

@GeneratedValue(strategy = GenerationType.IDENTITY)
- o Id ser auto-incrementável ao salvar no banco de dados



Configurações para conexão com o banco de daos MySQL:



spring:
  datasource:
    url: jdbc:mysql://localhost:3306/animal?useSSL=false&createDatabaseIfNotExist=true&useTimezone=true&serverTimezone=UTC
    username: root
    password: paraquesenha
  jpa:
    show-sql: true 
    hibernate:
      ddl-auto: update



url: jdbc:mysql://localhost:3306/animal?useSSL=false&createDatabaseIfNotExist=true&useTimezone=true&serverTimezone=UTC
- /animal - nome da base de dados (MySQL Workbench)
- useSSL - relacionado a certificado
- useTimeZone... - relacionado a problemas com fuso horário 


show-sql: true 
- mostrar Query SQL no Consoloe quando a aplicação rodar


ddl-auto: update
- toda vez que iniciar a aplicação o banco será atualizado

// --- 14 --- // 

JpaRepository
- conectado com o banco de dados
- já vem com métodos, portanto basta só fazer o "extends"
- ao extendê-lo, automaticamente a classe já é identificada como um Spring bean

!!!!!! Não deve usar as classes que são tabelas no banco de dados (que usam @Entity) como valores de @RequestBody diretamente no Controller !!!!!!	[ 2:55 ]

Padrão DTO
- representar essa classe para substitui-la nesse @RequestBody...
...nesse caso é utilizado uma coisa um pouco diferente de DTO...
...poderia se criar um sub-classe pra representar essa classe "Animal", mas como terá SÓ esse classe "Animal", não precisa

AnimalPostRequestBody
- basicamente é uma classe DTO (mas não é exatamente uma)
- se faz nessa classe exatamente o que se faria se tivesse um DTO ou qualquer outro tipo de padrão
- o POST não precisa do valor Id, o @Data já cuida disso
- essa classe facilita refatoração ou até mesmo compartilhar serviços como se fosse um contrato	

@Builder
- construir um objeto de um jeito diferente

return animalRepository.save(Animal.builder().name(animalPostRequestBody.getName()).build()); 
- Animal.builder().name(animalPostRequestBody.getName()).build()); // mesma coisa de ----> Animal animal = new Animal(null, animalPostRequestBody.getName());
- por padrão o "save()" vai salvar o objeto e retornar esse objeto já com um Id que foi auto-incrementado

// --- 15 --- //

Essa aula é sobre trocar aqueles métodos de build(), etc, por esse framework Mapstruct para agilizar e ter melhor performance

Pode colocar todos os Mappers dentro de um pacote só      OU     Pode criar vários pacotes separados
- varia de pessoa pra pessoa

(componentModel = "spring") 	[ 3:52 ]
- possibilitar fazer injeção de dependência caso seja preciso

classe AnimalMapper 	[ 4:35 ] 
- os métodos irão fazer automaticamente a conversão de todos os atributos que se tem dentro do objeto da classe DTO para um objeto da classe (associado a uma tabela)...
... nesse caso a classe DTO "AnimalPost.. e AnimalPut.." para a classe de entidade "Animal"

public static final AnimalMapper INSTANCE = Mappers.getMapper(AnimalMapper.class);
- forma de chamar esse métodos abstratos 
- ou seja, é uma instancia dessa 

// --- 16 --- //

É usado o @RequestParam para não causar ambiguidade, já que o @GetMapping está em dois métodos

@RequestParam
- usado para inserir valores nos parâmetros do método
- funciona colocando o sinal "?" depois do caminho da URL e em seguida o parâmetro "name=" e o valor desse parâmetro "Rottweiler"
Ex: ../find?name=Bulldog

@RequestParam(defaultValue = "")
- valor padrão caso não seja passado nenhum valor na URL

@RequestParam(required = false)
- não é mais obrigatório colocar valores valores em atributos, ou seja, pode colocar somente o caminho "/find", por exemplo, sem ter que colocar o "?name=..."

// --- 17 --- //

O tratamento de exceções é mais uma questão de padrão do projeto

@ResponseStatus(HttpStatus.BAD_REQUEST)
- retorne sempre o status HTTP - Bad Request (400) 

// --- 18 --- // 

Handler Global para as exceções do projeto

A parte de consitência é a parte mais importante quando se desenvolve uma aplicação

Fazer com o que possamos manipular o retorno de informações das exceções, ou seja, deixando de um jeito padronizado

Falar para todos os Controllers que quando se tiver uma exceção do tipo BadRequestException (exceção customizada), irá precisar utilizar o método__________...

@ControllerAdvice
- avisar para todos os Controllers que devem utilizar o que se colocar dentro da classe baseado em como se fosse uma "flag"
- a flag que será utilizada é a @ExceptionHandler

@ExceptionHandler(BadRequestException.class) 	 [ 3:10 ]
- caso seja lançado uma exceção desse tipo (BadRequestException) deve-se utilizar o método que essa Annotation se refere (e retornar um valor)...
... nesse caso o valor que está sendo retornado é um objeto do tipo "ResponseEntity<BadRequestExceptionDetails>" com detalhes do erro

// --- 19 --- //

Usar TRANSAÇÕES - depende de como seu banco de dados está estruturado

Caso o engine do seu banco de dados não for "InnoDB", significa que ele não tem suporte para transações

Então, se há uma situação que você precisa checar se suas ações, em caso de exceção, precisaram de um rollback use @Transactional

@Transactional
- o Spring não vai commitar uma transação enquanto o método não for finalizado (chegar no final)
- leva em conta somente Exceções tipo Unchecked (Runtime)

@Transactional(rollbackFor = Exception.class)
- agora também leva em conta exceções Checked (Exception) e Unchecked (Runtime)

// --- 20 --- //

@Column(nullable = false)
private String name;
- isso não atualiza o banco de dados, teria que ser manualmente, então não será utilizado

Será utilizado o pacote do Spring - SpringBoot Starter Validation (antes fazia parte do Spring mas foi separado)

Como não se está utilizando a classe entidade "Animal" direto  nos Controllers, usar os Validations nas classes DTO

@NotEmpty(message = "The animal name cannot be empty")
private String name;
- significa que esse atributo ao ser salvo no banco de dados não pode ser vazio nem nulo
- (foi somente na classe AnimalPostRequestBody)

Existem outras validações de campo que podem ser feitas com esse pacote, por exemplo:
- @URL
- @Min / @Max (numero)
- ...

@Valid
- dizer para o Spring para fazer estas validações automaticamente

Dessa forma foi possível fazer validações dos campos diretamente no Controller, então nem precisa se preocupar em fazer "if" que o Spring já tomará conta

// --- 21 --- //

Fazer com o que a classe "BadRequestExceptionDetails" seja a mesma para praticamente todas as exceções, só especializando conforme necessidade

@SuperBuilder
- para classes que serão extendidas e que extendem

Criar uma classe que vai trabalhar com os campos adicionais (geradas automaticamente) que se tem quando uma exceção @Valid é lançada...
... na qual esse @Valid é para conferir o valor dos atributos (se não é empty nem null) quando há o salvamento (POST) de novos objetos no banco de dados

final		[ 3:00 ]
- pois só há o @Getter e o @SuperBuilder

Handler
- forma de uma classe fazer o Controller interceptar as exceções e adicionar na exceção o que se definir no método referido...
... e que nesse caso será lançada uma exceção personalizada (bonitinha) do @Valid que antes era automática (monstruosa)

Descobrir qual exceção é lançada quando o objeto, ao tentar salvá-lo (POST) no banco dados, é empty ou null		[ 3:30 ] 	

...collect(Collectors.joining(", "));
- caso tenha mais de um campo/atributo na stream, separá-los por ", "

Dessa forma conseguimos padronizar as exceções para validação de campos
