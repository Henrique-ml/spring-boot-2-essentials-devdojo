@ResponseBody <- @RestController
- o retorno dos métodos dentro da classe serão apenas Strings
- imbutido na classe annotation @RestController


Jackson 
- serializador oficial do Spring
- criar os atributos JSON utilizando os GETTERS/SETTERS (error: 500 caso não tenha os get/set)


@Component
- transformar a classe em Bean (classe escaneável) para que o Spring possa trabalhar com ela
- @Controller e @Service são (quase) a mesma coisa

@RequiredArgsConstructor
- criar um Construtor da classe com somente métodos "final"

@Configuration
- transformar a classe em um Bean
- Marca a classe como uma fonte de definições de bean para o contexto do aplicativo
- vai colocar a classe de configuração no meio do "Filter Chain" (corrente de filtros)

@EnableAutoConfiguration
- configuração de propriedades, classes a serem executadas, etc.
- Diz ao Spring Boot para começar a adicionar beans com base nas configurações do classpath, outros beans e várias configurações de propriedade...
- ...Por exemplo, se spring-webmvcestiver no caminho de classe, essa anotação sinaliza o aplicativo como um aplicativo da web
- ... e ativa os principais comportamentos, como configurar um DispatcherServlet.

@ComponentScan
- varrer os pacotes, com as classes, no pacote principal onde essa anotação estiver 
- Diz ao Spring para procurar outros componentes, configurações e serviços no com/examplepacote, permitindo que ele encontre os controladores.

Básico do Spring para se inicializar uma aplicação, escanear toda a config e os componentes
- @EnableAutoConfiguration
- @ComponentScan		
- @Configuration

@SpringBootApplication
- é uma anotação de conveniência que adiciona todos os seguintes: @Configuration / @EnableAutoConfiguration / @ComponentScan 

// --- 05 --- //

Ao inserir a dependência Spring Boot Devtools
- Spring habilitará o Hot Swap, e entre outras coisas

Hot Swap 
- fazer somente o Build de pequenas mudanças feitas no código e não precisar reiniciar a aplicação inteira
- melhor performance, menos tempo, para rodar a aplicação

// --- 07 --- //

@Data 
- gerar getters/setters, hashCode e equals, toString, ...

@AllArgsConstructor
- gerar construtor com todos os atributos







Pacotes / Classes e suas responsabilidades
- Controllers: onde são os endpoints
- Service: lógica regra de negócios
- Repositories: a conexão diretamente com o banco de dados (Query's ficarão aqui)
- Entities: o que se tem no banco de dados








// --- 08 --- // - GET

ResponseEntity<>
- retornar informações extras de uma requisição HTTP. Ex: o status da requisição
- quando a resposta da requisição retornar direitinho, sem nenhum erro, não terá nenhuma alteração no resultado

.orElseThrow()		[ 5:35 ]
- na stream, retornar algo caso não encontre o objeto pedido
- por convenção as pessoas lançam o "Error 404", mas ele não apresenta tantas informções, então fazer um padrão mais explicativo
- no código utilizar um padrão, ou seja, usou no endpoint o - HttpStatus.BAD_REQUEST - então usar em outros endpoints também

properties.application -> propoerties.yml		[ 8:12 ]
- esconder o Stack Trace na requisição GET do erro do método finById() caso não seja encontrado um animal com aquele id

// --- 09 --- // - POST

O padrão de retorno de dados é o que define (Ex: o .orElseThrow acima)

Nesse caso irá se retornar um objeto inteiro

Há muitos lugares onde quando se faz a requisição POST, pode se receber no retorno:
- ou apenas um ID e um protocolo 201 (CREATED)
- ou só o protocolo 201 sem nenhum outro tipo de retorno
- ou o objeto inteiro


O método save() precisa de um "body" = ou seja, esse requisição precisa receber um objeto e ser mapeada para salva-la
- nesse caso usar o Jackson para fazer o mapeamento

Jackson funciona assim: 
- se ele encontrar o JSON com os atributos da requisição exatamente iguais aos atributos da classe ele fará o mapeamento
- caso o atributo não esteja como o mesmo nome ele será ignorado, não será mapeado (utilizar o @JsonProperty)

@JsonProperty
- fará com o que o atributo JSON seja mapeado mesmo sendo diferente do atributo classe 
- Ex:	
		@JsonProperty("name") // como será na requisição e ser mapeado para esse atributo da classe
		private nameCharacter; 
		
@ResponseStatus("HttpStatus.CREATED")
- retornar o protocolo 201 (CREATED)

// --- 10 --- // - DELETE

Padrão em retornar o BAD_REQUEST permanece
- animais.remove(findById(id)); // findById() que irá retornar

Protocolo 204 (NO CONTENT)
- algo ocorreu certo mas não retorno nenhum conteudo

Depotente e Idepontente			[ 5:15 ] 

// --- 11 --- // - PUT

Padrão em retornar o BAD_REQUEST permanece

PUT
- substituir o estado inteiro do objeto
- envia o objeto e esse objeto deve substituir completamente o existente

Retorna um NO CONTENT pois você já tem os dados

// --- 12 --- //

Colocar o MySQL nas dependências do pom.xml

// --- 13 --- // 

@Entity
- transformar a classe em uma tabela

@Id
- informar ao Spring que é um ID

@GeneratedValue(strategy = GenerationType.IDENTITY)
- o Id ser auto-incrementável ao salvar no banco de dados



Configurações para conexão com o banco de daos MySQL:



spring:
  datasource:
    url: jdbc:mysql://localhost:3306/animal?useSSL=false&createDatabaseIfNotExist=true&useTimezone=true&serverTimezone=UTC
    username: root
    password: paraquesenha
  jpa:
    show-sql: true 
    hibernate:
      ddl-auto: update



url: jdbc:mysql://localhost:3306/animal?useSSL=false&createDatabaseIfNotExist=true&useTimezone=true&serverTimezone=UTC
- /animal - nome da base de dados (MySQL Workbench)
- useSSL - relacionado a certificado
- useTimeZone... - relacionado a problemas com fuso horário 


show-sql: true 
- mostrar Query SQL no Consoloe quando a aplicação rodar


ddl-auto: update
- toda vez que iniciar a aplicação o banco será atualizado

// --- 14 --- // 

JpaRepository
- conectado com o banco de dados
- já vem com métodos, portanto basta só fazer o "extends"
- ao extendê-lo, automaticamente a classe já é identificada como um Spring bean

!!!!!! Não deve usar as classes que são tabelas no banco de dados (que usam @Entity) como valores de @RequestBody diretamente no Controller !!!!!!	[ 2:55 ]

Padrão DTO
- representar essa classe para substitui-la nesse @RequestBody...
...nesse caso é utilizado uma coisa um pouco diferente de DTO...
...poderia se criar um sub-classe pra representar essa classe "Animal", mas como terá SÓ esse classe "Animal", não precisa

AnimalPostRequestBody
- basicamente é uma classe DTO (mas não é exatamente uma)
- se faz nessa classe exatamente o que se faria se tivesse um DTO ou qualquer outro tipo de padrão
- o POST não precisa do valor Id, o @Data já cuida disso
- essa classe facilita refatoração ou até mesmo compartilhar serviços como se fosse um contrato	

@Builder
- construir um objeto de um jeito diferente

return animalRepository.save(Animal.builder().name(animalPostRequestBody.getName()).build()); 
- Animal.builder().name(animalPostRequestBody.getName()).build()); // mesma coisa de ----> Animal animal = new Animal(null, animalPostRequestBody.getName());
- por padrão o "save()" vai salvar o objeto e retornar esse objeto já com um Id que foi auto-incrementado

// --- 15 --- //

Essa aula é sobre trocar aqueles métodos de build(), etc, por esse framework Mapstruct para agilizar e ter melhor performance

Pode colocar todos os Mappers dentro de um pacote só      OU     Pode criar vários pacotes separados
- varia de pessoa pra pessoa

(componentModel = "spring") 	[ 3:52 ]
- possibilitar fazer injeção de dependência caso seja preciso

classe AnimalMapper 	[ 4:35 ] 
- os métodos irão fazer automaticamente a conversão de todos os atributos que se tem dentro do objeto da classe DTO para um objeto da classe (associado a uma tabela)...
... nesse caso a classe DTO "AnimalPost.. e AnimalPut.." para a classe de entidade "Animal"

public static final AnimalMapper INSTANCE = Mappers.getMapper(AnimalMapper.class);
- forma de chamar esse métodos abstratos 
- ou seja, é uma instancia dessa 

// --- 16 --- //

É usado o @RequestParam para não causar ambiguidade, já que o @GetMapping está em dois métodos

@RequestParam
- usado para inserir valores nos parâmetros do método
- funciona colocando o sinal "?" depois do caminho da URL e em seguida o parâmetro "name=" e o valor desse parâmetro "Rottweiler"
Ex: ../find?name=Bulldog

@RequestParam(defaultValue = "")
- valor padrão caso não seja passado nenhum valor na URL

@RequestParam(required = false)
- não é mais obrigatório colocar valores valores em atributos, ou seja, pode colocar somente o caminho "/find", por exemplo, sem ter que colocar o "?name=..."

// --- 17 --- //

O tratamento de exceções é mais uma questão de padrão do projeto

@ResponseStatus(HttpStatus.BAD_REQUEST)
- retorne sempre o status HTTP - Bad Request (400) 

// --- 18 --- // 

Handler Global para as exceções do projeto

A parte de consitência é a parte mais importante quando se desenvolve uma aplicação

Fazer com o que possamos manipular o retorno de informações das exceções, ou seja, deixando de um jeito padronizado

Falar para todos os Controllers que quando se tiver uma exceção do tipo BadRequestException (exceção customizada), irá precisar utilizar o método__________...

@ControllerAdvice
- avisar para todos os Controllers que devem utilizar o que se colocar dentro da classe baseado em como se fosse uma "flag"
- a flag que será utilizada é a @ExceptionHandler

@ExceptionHandler(BadRequestException.class) 	 [ 3:10 ]
- caso seja lançado uma exceção desse tipo (BadRequestException) deve-se utilizar o método que essa Annotation se refere (e retornar um valor)...
... nesse caso o valor que está sendo retornado é um objeto do tipo "ResponseEntity<BadRequestExceptionDetails>" com detalhes do erro

// --- 19 --- //

Usar TRANSAÇÕES - depende de como seu banco de dados está estruturado

Caso o engine do seu banco de dados não for "InnoDB", significa que ele não tem suporte para transações

Então, se há uma situação que você precisa checar se suas ações, em caso de exceção, precisaram de um rollback use @Transactional

@Transactional
- o Spring não vai commitar uma transação enquanto o método não for finalizado (chegar no final)
- leva em conta somente Exceções tipo Unchecked (Runtime)

@Transactional(rollbackFor = Exception.class)
- agora também leva em conta exceções Checked (Exception) e Unchecked (Runtime)

// --- 20 --- //

@Column(nullable = false)
private String name;
- isso não atualiza o banco de dados, teria que ser manualmente, então não será utilizado

Será utilizado o pacote do Spring - SpringBoot Starter Validation (antes fazia parte do Spring mas foi separado)

Como não se está utilizando a classe entidade "Animal" direto  nos Controllers, usar os Validations nas classes DTO

@NotEmpty(message = "The animal name cannot be empty")
private String name;
- significa que esse atributo ao ser salvo no banco de dados não pode ser vazio nem nulo
- (foi somente na classe AnimalPostRequestBody)

Existem outras validações de campo que podem ser feitas com esse pacote, por exemplo:
- @URL
- @Min / @Max (numero)
- ...

@Valid
- dizer para o Spring para fazer estas validações automaticamente

Dessa forma foi possível fazer validações dos campos diretamente no Controller, então nem precisa se preocupar em fazer "if" que o Spring já tomará conta

// --- 21 --- //

Fazer com o que a classe "BadRequestExceptionDetails" seja a mesma para praticamente todas as exceções, só especializando conforme necessidade

@SuperBuilder
- para classes que serão extendidas e que extendem

Criar uma classe que vai trabalhar com os campos adicionais (geradas automaticamente) que se tem quando uma exceção @Valid é lançada...
... na qual esse @Valid é para conferir o valor dos atributos (se não é empty nem null) quando há o salvamento (POST) de novos objetos no banco de dados

final		[ 3:00 ]
- pois só há o @Getter e o @SuperBuilder

Handler
- forma de uma classe fazer o Controller interceptar as exceções e adicionar na exceção o que se definir no método referido...
... e que nesse caso será lançada uma exceção personalizada (bonitinha) do @Valid que antes era automática (monstruosa)

Descobrir qual exceção é lançada quando o objeto, ao tentar salvá-lo (POST) no banco dados, é empty ou null		[ 3:30 ] 	

...collect(Collectors.joining(", "));
- caso tenha mais de um campo/atributo na stream, separá-los por ", "

Dessa forma conseguimos padronizar as exceções para validação de campos

// --- 22 --- //

protected ResponseEntity<Object> handleExceptionInternal(...)
- método responsável por montar praticamente o corpo de todas as exceções (mensagens de erro) do Spring...
... onde essas exceções são as classes que são lançadas e que estão inseridas internamente na Annotation @ExceptionHandler

Iremos sobrescrever (@Override) esse método principal com um corpo personalizado, parecido com os que criamos

@Override
protected ResponseEntity<Object> handleMethodArgumentNotValid(...)
- como esse método já era tratado pelo Spring, apenas fizemos o @Override dele e um pequeno ajuste

Dessa forma conseguimos tratar ainda mais exceções e obtendo uma padronização ainda maior no projeto

// --- 23 --- //

Paginação
- uma das coisas mais comuns quando se está trabalhando com qualquer tipo de API...
... pois você não quer 	retornar todos os dados de uma vez só para seu front-end ou mobile que faz as chamadas para o back-end

A Paginação oferece uma grande flexibilidade para quem quer que esteja consumindo sua API...
... principalmente se você estiver desenvolvendo aplicações que serão consumidas pelo mobile...
... pois você não quer retornar uma lista com 600 nomes, ou até mais, tudo de uma vez kkkkk

// --- 24 --- //

Objetivo da aula é como trocar o padrão do tamanho das Páginas retornadas...
... ou seja, ao invés fazer isso através da requisição na URL, configurar o retorno das páginas no próprio Spring

Será feito uma pequena adição que vamos criar que afetará o Spring como um todo, ou seja, criar uma nova configuração

Para a configuração ser aplicada globalmente colocar a Annotation @Configuration

pageHandler.setFallbackPageable(PageRequest.of(page, size));
- page: a página que vai ser exibida por padrão.			
Ex: tem 3 páginas (0 - 2), caso seja - page=1 - a segunda página será exibida por padrão

- size: a quantidade de dados retornados em uma página		
Ex: tem 10 dados no banco de dados, caso seja - size=5 - os dados serão divididos em 2 páginas retornando 5 dados em cada página

Dessa forma que se faz uma configuração global para sobrescrever a configuração já existente do Spring 

// --- 25 --- //

Por padrão ao adicionar o Pageable, já pode-se utilizar o método/parâmetro [ sort ]
Ex: localhost:8080/animais?size=20&sort=name,asc

Lembrando que todas as requisições, salvamentos, etc.. estão sendo feitas no nível do banco de dados e não no nível da aplicação

O Hibernate, no console, está imprimindo o log SQL fora do padrão quando é um log Spring
- isso acontece pois quando se utiliza o [ show-sql: true ] nas configurações...
... simplesmente será impresso diretamente o SQL no console sem utilizar nenhum tipo de Appender (Spring usa o Logback - log padrão do console)




logging:
  level:
    org:
      hibernate:
        SQL: DEBUG
        
        
Com essas novas configurações, o SQL agora faz parte do Logback padrão do Spring
E além deixar mais organizado, melhora a performance ao invés de só imprimir o SQL no console

// --- 26 --- //

Quando está se desenvolvendo uma aplicação em algum você precisará fazer uma requisição para um serviço/url externa...
... então o Spring disponibiliza uma biblioteca que fará essa chamada para o serviço externo, fazendo automaticamente o mapeamento dos dados para sua classe


new RestTemplate().getForEntity("http://localhost:8080/animais/2", Animal.class);
- executando um GET
- Animal.class: como a requisição irá retornar um JSON, eu falo para o Spring para tentar fazer mapeamento automaticamente usando o próprio Jackson...
... e esse [ Animal.class ] significa o qual o tipo para fazer esse mapeamento
- retornará o objeto e mais algumas informações extras que podem ser pertinentes no desenvolvimento do projeto


Caso queira pegar somente o objeto em si (body) sem as informações extras, faça:
- new RestTemplate().getForEntity("http://localhost:8080/animais/2", Animal.class).getBody();
ou
- new RestTemplate().getForObject("http://localhost:8080/animais/2", Animal.class);


Essas requisições podem ser usadas também com um ou mais placeholders (placeholders são substituidos pelos valores na ordem que são colocados):
- new RestTemplate().getForEntity("http://localhost:8080/animais/{id}", Animal.class, 2);
ou
- new RestTemplate().getForObject("http://localhost:8080/animais/{id}", Animal.class, 2);

// --- 27 --- //

Não entendi muito bem - criando outro endpoint não paginável		[ 0:20 - 2:10 ]
- talvez seja para que o retorno dos objetos sejam simples e facilitar a conversão do Array para List ao retornar a List automaticamente

Para fazer o mapeamento automático dos dados de uma coleção, faça:
- Animal[] animais = new RestTemplate().getForObject("http://localhost:8080/animais/all", Animal[].class);				(objeto "animais" é um array e não uma list)

Não aconselhável converter manualemente esse Array para List pois estaria fazendo um Cast, então pode-se utilizar o Super Type Token

Super Type Token
- fará essa conversão de Array para List automaticamente

E com o RestTemplate esse Super Type Token se dá através do método "exchange()" (flexibilidade) com o "new ParameterizedTypeReference<>()"	


ResponseEntity<List<Animal>> exchange = new RestTemplate().exchange("http://localhost:8080/animais/all",
				HttpMethod.GET,
				null,
				new ParameterizedTypeReference<List<Animal>>() {});
- null: pois não será enviado nada, é apenas uma requisição GET
- retornar lista automaticamente


Requisições do RestTemplate:
- array - getForObject()
- lista - new ParameterizedTypeReference<>()

// --- 28 --- //

POST é praticamente quase a mesma do GET

O método "exchange()" retorna um objeto dentro de um Wrapper (que é o ResponseEntity<> com aquelas infos extras que podem ser pertinentes) 

new RestTemplate().postForObject("http://localhost:8080/animais", shihtzu, Animal.class);
- shitzu: objeto criado para salvar no banco de dados
- Animal.class: o tipo que será retornado quando houver esta requisição POST


ResponseEntity<Animal> pitbullSaved = new RestTemplate().exchange("http://localhost:8080/animais",
				HttpMethod.POST,
				new HttpEntity<>(pitbull), 
				Animal.class);
- new HttpEntity<>(pitbull): o objeto que será enviado na requisição POST para salvá-lo no banco de dados
- Animal.class: o tipo que será retornado quando houver esta requisição POST


private static HttpHeaders createJsonHeader() {
- enviar um header dizendo que o Content-Type é um application Json (informações extras retornadas - Wrapper)

// --- 29 --- //

PUT e DELETE retornam Void em uma requisição
E os dois são bem parecidos em questão de código

ResponseEntity<Void> pitbullUpdated = new RestTemplate().exchange("http://localhost:8080/animais",
				HttpMethod.PUT,
				new HttpEntity<>(animalToBeUpdated, createJsonHeader()), 
				Void.class);
- ResponseEntity<Void> e Void.class: pois a requisição PUT retorna Void, ou seja, não retorna nada


ResponseEntity<Void> pitbullDelete = new RestTemplate().exchange("http://localhost:8080/animais",
				HttpMethod.DELETE,
				null,
				Void.class, 
				animalToBeUpdated.getId());
- null: pois não está enviando nenhuma entidade/objeto/dado (mais ainda sim pode-se colocar os headers - caso seja necessário autenticação)
- ResponseEntity<Void> e Void.class: pois a requisição DELETE retorna Void, ou seja, não retorna nada


ResponseEntity
- para ter o número do protocólo HTTP referente as requisições feitas e outros dados extras

// --- 30 --- //

TESTES UNITÁRIOS DEVEM FAZER PARTE DA SUA APLICAÇÃO
- seja no trabalho
- entrevista de emprego
- projetos pessoais

Para os testes utilizaremos o banco de dados em memória H2
- banco de dados que é criado assim que a aplicação se inicia e destruído assim que ela se encerra


@DisplayName("")
- trocar o nome padrão do teste (o nome da classe) por outro


Para rodar os testes não é necessário ter a aplicação SpringBoot rodando

Não está sendo testado o banco de dados em si, mas sim o repositório da aplicação pra ver se está tudo ok...
... e ver se as Querys estão funcionando da forma que se espera
(O ideal mesmo seria testar exatamente o banco de dados que se está desenvolvendo a aplicação)


@Autowired em caso de testes pode ser utilizado normalmente


Há convenções de (7 ou 8 opções) de como normear testes, mas aqui será a modo DevDojo
- nomear o método (o que será testado_o que esse método deve fazer_quando fazer)


Assertions.assertThat(animalSaved).isNotNull();
- verificar se o objeto não é null

Assertions.assertThat(animalSaved.getId()).isNotNull();
- verificar se o banco de dados criou corretamento o Id, e ele não é null

Assertions.assertThat(animalSaved.getName()).isEqualTo(animalToBeSaved.getName());
- verificar se o valor salvo foi igual ao que foi pedido para ser salvo

// --- 31 --- //

Teste de Update:
void save_UpdatesAnimal_WhenSuccessful() {


Teste de Delete:
void delete_RemovesAnimal_WhenSuccessful() {


Teste de FindById:
void findByName_ReturnsListOfAnimal_WhenSuccessful() {


Se quiser fazer diferença na entrevista de emprego trabalhe com casos que não estão explicitamente visíveis


Teste de FindByName retorna lista vazia:
void findByName_ReturnsEmptyList_WhenAnimalIsNotFound() {
- método criado para garantir que seja retornado uma lista vazia (e não null) quando um objeto procurado não for encontrado


A classe "Assertions" verifica e da um "ok" os dados cumpram/sejam aquilo escrito na expressão...
... ou seja, é aquilo que se espera que aconteça

Então caso alguém modifique o comportamento dos métodos de repositório, o Assertions avisará

