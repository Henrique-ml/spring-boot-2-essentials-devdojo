@ResponseBody <- @RestController
- o retorno dos métodos dentro da classe serão apenas Strings
- imbutido na classe annotation @RestController


Jackson 
- serializador oficial do Spring
- criar os atributos JSON utilizando os GETTERS/SETTERS (error: 500 caso não tenha os get/set)


@Component
- transformar a classe em Bean (classe escaneável) para que o Spring possa trabalhar com ela
- @Controller e @Service são (quase) a mesma coisa

@RequiredArgsConstructor
- criar um Construtor da classe com somente métodos "final"

@Configuration
- transformar a classe em um Bean
- Marca a classe como uma fonte de definições de bean para o contexto do aplicativo
- vai colocar a classe de configuração no meio do "Filter Chain" (corrente de filtros)

@EnableAutoConfiguration
- configuração de propriedades, classes a serem executadas, etc.
- Diz ao Spring Boot para começar a adicionar beans com base nas configurações do classpath, outros beans e várias configurações de propriedade...
- ...Por exemplo, se spring-webmvcestiver no caminho de classe, essa anotação sinaliza o aplicativo como um aplicativo da web
- ... e ativa os principais comportamentos, como configurar um DispatcherServlet.

@ComponentScan
- varrer os pacotes, com as classes, no pacote principal onde essa anotação estiver 
- Diz ao Spring para procurar outros componentes, configurações e serviços no com/examplepacote, permitindo que ele encontre os controladores.

Básico do Spring para se inicializar uma aplicação, escanear toda a config e os componentes
- @EnableAutoConfiguration
- @ComponentScan		
- @Configuration

@SpringBootApplication
- é uma anotação de conveniência que adiciona todos os seguintes: @Configuration / @EnableAutoConfiguration / @ComponentScan 

// --- 05 --- //

Ao inserir a dependência Spring Boot Devtools
- Spring habilitará o Hot Swap, e entre outras coisas

Hot Swap 
- fazer somente o Build de pequenas mudanças feitas no código e não precisar reiniciar a aplicação inteira
- melhor performance, menos tempo, para rodar a aplicação

// --- 07 --- //

@Data 
- gerar getters/setters, hashCode e equals, toString, ...

@AllArgsConstructor
- gerar construtor com todos os atributos


Pacotes / Classes e suas responsabilidades
- Controllers: onde são os endpoints
- Service: lógica regra de negócios
- Repositories: a conexão diretamente com o banco de dados (Query's ficarão aqui)
- Entities: o que se tem no banco de dados

// --- 08 --- // - GET

ResponseEntity<>
- retornar informações extras de uma requisição HTTP. Ex: o status da requisição
- quando a resposta da requisição retornar direitinho, sem nenhum erro, não terá nenhuma alteração no resultado

.orElseThrow()		[ 5:35 ]
- na stream, retornar algo caso não encontre o objeto pedido
- por convenção as pessoas lançam o "Error 404", mas ele não apresenta tantas informções, então fazer um padrão mais explicativo
- no código utilizar um padrão, ou seja, usou no endpoint o - HttpStatus.BAD_REQUEST - então usar em outros endpoints também

properties.application -> propoerties.yml		[ 8:12 ]
- esconder o Stack Trace na requisição GET do erro do método finById() caso não seja encontrado um animal com aquele id

// --- 09 --- // - POST

O padrão de retorno de dados é o que define (Ex: o .orElseThrow acima)

Nesse caso irá se retornar um objeto inteiro

Há muitos lugares onde quando se faz a requisição POST, pode se receber no retorno:
- ou apenas um ID e um protocolo 201 (CREATED)
- ou só o protocolo 201 sem nenhum outro tipo de retorno
- ou o objeto inteiro


O método save() precisa de um "body" = ou seja, esse requisição precisa receber um objeto e ser mapeada para salva-la
- nesse caso usar o Jackson para fazer o mapeamento

Jackson funciona assim: 
- se ele encontrar o JSON com os atributos da requisição exatamente iguais aos atributos da classe ele fará o mapeamento
- caso o atributo não esteja como o mesmo nome ele será ignorado, não será mapeado (utilizar o @JsonProperty)

@JsonProperty
- fará com o que o atributo JSON seja mapeado mesmo sendo diferente do atributo classe 
- Ex:	
		@JsonProperty("name") // como será na requisição e ser mapeado para esse atributo da classe
		private nameCharacter; 
		
@ResponseStatus("HttpStatus.CREATED")
- retornar o protocolo 201 (CREATED)

// --- 10 --- // - DELETE

Padrão em retornar o BAD_REQUEST permanece
- animais.remove(findById(id)); // findById() que irá retornar

Protocolo 204 (NO CONTENT)
- algo ocorreu certo mas não retorno nenhum conteudo

Depotente e Idepontente			[ 5:15 ] 

// --- 11 --- // - PUT

Padrão em retornar o BAD_REQUEST permanece

PUT
- substituir o estado inteiro do objeto
- envia o objeto e esse objeto deve substituir completamente o existente

Retorna um NO CONTENT pois você já tem os dados

// --- 12 --- //

Colocar o MySQL nas dependências do pom.xml

// --- 13 --- // 

@Entity
- transformar a classe em uma tabela

@Id
- informar ao Spring que é um ID

@GeneratedValue(strategy = GenerationType.IDENTITY)
- o Id ser auto-incrementável ao salvar no banco de dados



Configurações para conexão com o banco de daos MySQL:



spring:
  datasource:
    url: jdbc:mysql://localhost:3306/animal?useSSL=false&createDatabaseIfNotExist=true&useTimezone=true&serverTimezone=UTC
    username: root
    password: paraquesenha
  jpa:
    show-sql: true 
    hibernate:
      ddl-auto: update



url: jdbc:mysql://localhost:3306/animal?useSSL=false&createDatabaseIfNotExist=true&useTimezone=true&serverTimezone=UTC
- /animal - nome da base de dados (MySQL Workbench)
- useSSL - relacionado a certificado
- useTimeZone... - relacionado a problemas com fuso horário 


show-sql: true 
- mostrar Query SQL no Consoloe quando a aplicação rodar


ddl-auto: update
- toda vez que iniciar a aplicação o banco será atualizado

// --- 14 --- // 

JpaRepository
- conectado com o banco de dados
- já vem com métodos, portanto basta só fazer o "extends"
- ao extendê-lo, automaticamente a classe já é identificada como um Spring bean

Não deve usar as classes que são tabelas no banco de dados (que usam @Entity) como valores de @RequestBody diretamente no Controller 	[ 2:55 ]

Padrão DTO
- representar essa classe para substitui-la nesse @RequestBody...
...nesse caso é utilizado uma coisa um pouco diferente de DTO...
...poderia se criar um sub-classe pra representar essa classe "Animal", mas como terá SÓ esse classe "Animal", não precisa

AnimalPostRequestBody
- basicamente é uma classe DTO (mas não é exatamente uma)
- se faz nessa classe exatamente o que se faria se tivesse um DTO ou qualquer outro tipo de padrão
- o POST não precisa do valor Id, o @Data já cuida disso
- essa classe facilita refatoração ou até mesmo compartilhar serviços como se fosse um contrato	

@Builder
- construir um objeto de um jeito diferente

return animalRepository.save(Animal.builder().name(animalPostRequestBody.getName()).build()); 
- Animal.builder().name(animalPostRequestBody.getName()).build()); // mesma coisa de ----> Animal animal = new Animal(null, animalPostRequestBody.getName());
- por padrão o "save()" vai salvar o objeto e retornar esse objeto já com um Id que foi auto-incrementado







